//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "Package", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (Chumpinate.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a Chumpinate-test.ck boilerplate ChucK program
//      to help test your chugin (see Chumpinate-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"

// general includes
#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <string>
#include <vector>
#include <nlohmann/json.hpp>

using std::optional;
using std::string;
using std::vector;
using json = nlohmann::json;

namespace fs = std::filesystem;


// declaration of chugin constructor
CK_DLL_CTOR( package_ctor );
CK_DLL_CTOR( package_ctor_name );
// declaration of chugin desctructor
CK_DLL_DTOR( package_dtor );

// example of getter/setter
CK_DLL_MFUN( package_setParam );
CK_DLL_MFUN( package_getParam );

CK_DLL_MFUN( package_setName );
CK_DLL_MFUN( package_getName );

CK_DLL_MFUN( package_setAuthor );

CK_DLL_MFUN( package_setAuthors );
CK_DLL_MFUN( package_getAuthors );

CK_DLL_MFUN( package_setHomepage );
CK_DLL_MFUN( package_getHomepage );

CK_DLL_MFUN( package_setRepository );
CK_DLL_MFUN( package_getRepository );

CK_DLL_MFUN( package_setLicense );
CK_DLL_MFUN( package_getLicense );

CK_DLL_MFUN( package_setDescription );
CK_DLL_MFUN( package_getDescription );

CK_DLL_MFUN( package_setKeywords );
CK_DLL_MFUN( package_getKeywords );

CK_DLL_MFUN( package_generatePackageDefinition );

// this is a special offset reserved for chugin internal data
t_CKINT package_data_offset = 0;


//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class Package
{
public:
  // constructor
  Package( )
  {
  }

  Package( string _name )
  {
    name = _name;
  }

  // for chugins extending UGen
  SAMPLE tick( SAMPLE in )
  {
    // default: this passes whatever input is patched into chugin
    return in;
  }

  // set parameter example
  t_CKFLOAT setParam( t_CKFLOAT p )
  {
    m_param = p;
    return p;
  }

  // get parameter example
  t_CKFLOAT getParam() { return m_param; }

  string setName( string _name ) {
    name = _name;
    return _name;
  }

  string getName() {
    return name;
  }

  string setAuthor( string _author ) {
    authors = {_author};
    return _author;
  }

  vector<string> setAuthors( vector<string> _authors ) {
    authors = _authors;
    return _authors;
  }

  vector<string> getAuthors() {
    return authors;
  }

  string setHomepage( string _homepage) {
    homepage = _homepage;
    return _homepage;
  }

  string getHomepage() {
    return homepage.value_or("");
  }

  string setRepository( string _repository ) {
    repository = _repository;
    return _repository;
  }

  string getRepository() {
    return repository.value_or("");
  }

  string setLicense( string _license ) {
    license = _license;
    return _license;
  }

  string getLicense() {
    return license.value_or("");
  }

  string setDescription( string _description ) {
    description = _description;
    return _description;
  }

  string getDescription() {
    return description.value_or("");
  }

  vector<string> setKeywords( vector<string> _keywords ) {
    keywords = _keywords;
    return _keywords;
  }

  vector<string> getKeywords() {
    return keywords;
  }

  t_CKINT generatePackageDefinition( fs::path json_path ) {
    json j = {
      {"name", name}
    };

    if (authors.size() > 0) j["authors"] = authors;
    if (homepage) j["homepage"] = homepage.value();
    if (repository) j["repository"] = repository.value();
    if (license) j["license"] = license.value();
    if (description) j["description"] = description.value();
    if (keywords.size() > 0) j["keywords"] = keywords;

    std::ofstream o(json_path);
    o << std::setw(4) << j << std::endl;
    o.close();

    return true;
  }


private:
  // instance data
  t_CKFLOAT m_param;
  string name;
  vector<string> authors;
  optional<string> homepage;
  optional<string> repository;
  optional<string> license;
  optional<string> description;
  vector<string> keywords;
};


//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( Package )
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "v0.1.0" );
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "Nick Shaheed" );
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "Construct a package for chump" );
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
    // (optional) contact email
    QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "nshaheed@ccrma.stanford.edu" );
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( Package )
{
    // generally, don't change this...
    QUERY->setname( QUERY, "Package" );

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class( QUERY, "Package", "Object" );

    // register default constructor
    QUERY->add_ctor( QUERY, package_ctor );
    // NOTE constructors can be overloaded like any other functions,
    // each overloaded constructor begins with `QUERY->add_ctor()`
    // followed by a sequence of `QUERY->add_arg()`
    QUERY->add_ctor( QUERY, package_ctor_name );
    QUERY->add_arg(QUERY, "string", "name");

    // register the destructor (probably no need to change)
    QUERY->add_dtor( QUERY, package_dtor );

    // example of adding setter method
    QUERY->add_mfun( QUERY, package_setParam, "float", "param" );
    // example of adding argument to the above method
    QUERY->add_arg( QUERY, "float", "arg" );

    // example of adding getter method
    QUERY->add_mfun( QUERY, package_getParam, "float", "param" );

    QUERY->add_mfun( QUERY, package_setName, "string", "name" );
    QUERY->add_arg( QUERY, "string", "name" );
    QUERY->add_mfun( QUERY, package_getName, "string", "name" );

    QUERY->add_mfun( QUERY, package_setAuthor, "string[]", "authors" );
    QUERY->add_arg( QUERY, "string", "author" );

    QUERY->add_mfun( QUERY, package_setAuthors, "string[]", "authors" );
    QUERY->add_arg( QUERY, "string[]", "authors" );

    QUERY->add_mfun( QUERY, package_getAuthors, "string[]", "authors" );

    QUERY->add_mfun( QUERY, package_setHomepage, "string", "homepage" );
    QUERY->add_arg( QUERY, "string", "homepage" );
    QUERY->add_mfun( QUERY, package_getHomepage, "string", "homepage" );

    QUERY->add_mfun( QUERY, package_setRepository, "string", "repository" );
    QUERY->add_arg( QUERY, "string", "repository" );
    QUERY->add_mfun( QUERY, package_getRepository, "string", "repository" );

    QUERY->add_mfun( QUERY, package_setLicense, "string", "license" );
    QUERY->add_arg( QUERY, "string", "license" );
    QUERY->add_mfun( QUERY, package_getLicense, "string", "license" );

    QUERY->add_mfun( QUERY, package_setDescription, "string", "description" );
    QUERY->add_arg( QUERY, "string", "description" );
    QUERY->add_mfun( QUERY, package_getDescription, "string", "description" );

    QUERY->add_mfun( QUERY, package_setKeywords, "string[]", "keywords" );
    QUERY->add_arg( QUERY, "string[]", "keywords" );
    QUERY->add_mfun( QUERY, package_getKeywords, "string[]", "keywords" );

    QUERY->add_mfun( QUERY, package_generatePackageDefinition, "int", "generatePackageDefinition" );
    QUERY->add_arg( QUERY, "string", "path" );

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    package_data_offset = QUERY->add_mvar( QUERY, "int", "@c_data", false );

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class( QUERY );

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the default constructor
CK_DLL_CTOR( package_ctor )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, package_data_offset ) = 0;

    // instantiate our internal c++ class representation
    Package * c_obj = new Package( );

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, package_data_offset ) = (t_CKINT)c_obj;
}



CK_DLL_CTOR(package_ctor_name )
{
  // get the offset where we'll store our internal c++ class pointer
  OBJ_MEMBER_INT( SELF, package_data_offset ) = 0;

  std::string name = GET_NEXT_STRING_SAFE(ARGS);

  // instantiate our internal c++ class representation
  Package * c_obj = new Package( name  );

  // store the pointer in the ChucK object member
  OBJ_MEMBER_INT( SELF, package_data_offset ) = (t_CKINT)c_obj;
}




// implementation for the destructor
CK_DLL_DTOR( package_dtor )
{
    // get our c++ class pointer
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE( c_obj );
    // set the data field to 0
    OBJ_MEMBER_INT( SELF, package_data_offset ) = 0;
}



// example implementation for setter
CK_DLL_MFUN( package_setParam )
{
    // get our c++ class pointer
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

    // call setParam() and set the return value
    RETURN->v_float = c_obj->setParam( arg1 );
}


// example implementation for getter
CK_DLL_MFUN(package_getParam)
{
    // get our c++ class pointer
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    // call getParam() and set the return value
    RETURN->v_float = c_obj->getParam();
}

CK_DLL_MFUN( package_setName ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string arg1 = GET_NEXT_STRING_SAFE( ARGS );

    string val = c_obj->setName( arg1 );

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}


CK_DLL_MFUN( package_getName ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string val = c_obj->getName();

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}

CK_DLL_MFUN( package_setAuthor ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string arg1 = GET_NEXT_STRING_SAFE( ARGS );

    string val = c_obj->setAuthor( arg1 );

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}

CK_DLL_MFUN( package_setAuthors ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    Chuck_ArrayInt * args = (Chuck_ArrayInt *) GET_NEXT_OBJECT(ARGS);

    if(args == NULL) {
      fprintf( stderr, "Package.authors(): argument 'authors' is null\n" );
      RETURN->v_object = 0;
      return;
    }

    std::vector<std::string> args_vector;

    t_CKINT size = API->object->array_int_size(args);

    for (int i = 0; i < size; i++) {
      t_CKUINT arg = API->object->array_int_get_idx(args, i);
      Chuck_String* arg_str = (Chuck_String*)arg;

      args_vector.push_back(API->object->str(arg_str));
    }

    c_obj->setAuthors( args_vector );

    RETURN->v_object = (Chuck_Object*) args;
}

CK_DLL_MFUN( package_getAuthors ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    // create array to be returned
    Chuck_ArrayInt* arr = (Chuck_ArrayInt*)API->object->create(SHRED, API->type->lookup(VM, "string[]"), false);

    std::vector<string> vals = c_obj->getAuthors();


   // populate array
    for (auto val : vals) {
      Chuck_String* val_ckstr = API->object->create_string(
          VM, val.c_str(), false);

      // OBJ_MEMBER_INT(val_ckstr, package_data_offset) = (t_CKINT)val_ckstri;
      API->object->array_int_push_back(arr, (t_CKINT)val_ckstr);
    }

    RETURN->v_object = (Chuck_Object*) arr;
}

CK_DLL_MFUN( package_setHomepage ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string arg1 = GET_NEXT_STRING_SAFE( ARGS );

    string val = c_obj->setHomepage( arg1 );

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}


CK_DLL_MFUN( package_getHomepage ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string val = c_obj->getHomepage();

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}

CK_DLL_MFUN( package_setRepository ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string arg1 = GET_NEXT_STRING_SAFE( ARGS );

    string val = c_obj->setRepository( arg1 );

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}
CK_DLL_MFUN( package_getRepository ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string val = c_obj->getRepository();

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}

CK_DLL_MFUN( package_setLicense ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string arg1 = GET_NEXT_STRING_SAFE( ARGS );

    string val = c_obj->setLicense( arg1 );

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}
CK_DLL_MFUN( package_getLicense ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string val = c_obj->getLicense();

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}

CK_DLL_MFUN( package_setDescription ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string arg1 = GET_NEXT_STRING_SAFE( ARGS );

    string val = c_obj->setDescription( arg1 );

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}
CK_DLL_MFUN( package_getDescription ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    string val = c_obj->getDescription();

    RETURN->v_string = (Chuck_String*)API->object->create_string(VM, val.c_str(), false);
}

CK_DLL_MFUN( package_setKeywords ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    Chuck_ArrayInt * args = (Chuck_ArrayInt *) GET_NEXT_OBJECT(ARGS);

    if(args == NULL) {
      fprintf( stderr, "Package.authors(): argument 'keywords' is null\n" );
      RETURN->v_object = 0;
      return;
    }

    std::vector<std::string> args_vector;

    t_CKINT size = API->object->array_int_size(args);

    for (int i = 0; i < size; i++) {
      t_CKUINT arg = API->object->array_int_get_idx(args, i);
      Chuck_String* arg_str = (Chuck_String*)arg;

      args_vector.push_back(API->object->str(arg_str));
    }

    c_obj->setKeywords( args_vector );

    RETURN->v_object = (Chuck_Object*) args;
}
CK_DLL_MFUN( package_getKeywords ){
    Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

    // create array to be returned
    Chuck_ArrayInt* arr = (Chuck_ArrayInt*)API->object->create(SHRED, API->type->lookup(VM, "string[]"), false);

    std::vector<string> vals = c_obj->getKeywords();


   // populate array
    for (auto val : vals) {
      Chuck_String* val_ckstr = API->object->create_string(
          VM, val.c_str(), false);

      // OBJ_MEMBER_INT(val_ckstr, package_data_offset) = (t_CKINT)val_ckstri;
      API->object->array_int_push_back(arr, (t_CKINT)val_ckstr);
    }

    RETURN->v_object = (Chuck_Object*) arr;
}

CK_DLL_MFUN( package_generatePackageDefinition ){
  Package * c_obj = (Package *)OBJ_MEMBER_INT( SELF, package_data_offset );

  string arg1 = GET_NEXT_STRING_SAFE( ARGS );

  t_CKINT val = c_obj->generatePackageDefinition( arg1 );

  RETURN->v_int = val;
}


/**************************
 * PackageVersion Defintion
 **************************/

// declaration of chugin constructor
CK_DLL_CTOR( package_version_ctor );
// declaration of chugin desctructor
CK_DLL_DTOR( package_version_dtor );

// example of getter/setter
CK_DLL_MFUN( package_version_setParam );
CK_DLL_MFUN( package_version_getParam );

// this is a special offset reserved for chugin internal data
t_CKINT package_version_data_offset = 0;


//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class PackageVersion
{
public:
    // constructor
    PackageVersion( t_CKFLOAT fs )
    {
        m_param = 0;
    }

    // set parameter example
    t_CKFLOAT setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    // get parameter example
    t_CKFLOAT getParam() { return m_param; }

private:
    // instance data
    t_CKFLOAT m_param;
};


// //-----------------------------------------------------------------------------
// // info function: ChucK calls this when loading/probing the chugin
// // NOTE: please customize these info fields below; they will be used for
// // chugins loading, probing, and package management and documentation
// //-----------------------------------------------------------------------------
// CK_DLL_INFO( PackageVersion )
// {
//     // the version string of this chugin, e.g., "v1.2.1"
//     QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "" );
//     // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
//     QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "" );
//     // text description of this chugin; what is it? what does it do? who is it for?
//     QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "" );
//     // (optional) URL of the homepage for this chugin
//     QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
//     // (optional) contact email
//     QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "" );
// }


// //-----------------------------------------------------------------------------
// // query function: ChucK calls this when loading the chugin
// // modify this function to define this chugin's API and language extensions
// //-----------------------------------------------------------------------------
// CK_DLL_QUERY( PackageVersion )
// {
//     // generally, don't change this...
//     QUERY->setname( QUERY, "PackageVersion" );

//     // ------------------------------------------------------------------------
//     // begin class definition(s); will be compiled, verified,
//     // and added to the chuck host type system for use
//     // ------------------------------------------------------------------------
//     // NOTE to create a non-UGen class, change the second argument
//     // to extend a different ChucK class (e.g., "Object")
//     QUERY->begin_class( QUERY, "PackageVersion", "UGen" );

//     // register default constructor
//     QUERY->add_ctor( QUERY, package_version_ctor );
//     // NOTE constructors can be overloaded like any other functions,
//     // each overloaded constructor begins with `QUERY->add_ctor()`
//     // followed by a sequence of `QUERY->add_arg()`

//     // register the destructor (probably no need to change)
//     QUERY->add_dtor( QUERY, package_version_dtor );

//     // for UGens only: add tick function
//     // NOTE a non-UGen class should remove or comment out this next line
//     QUERY->add_ugen_func( QUERY, package_version_tick, NULL, 1, 1 );
//     // NOTE: if this is to be a UGen with more than 1 channel,
//     // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
//     // and declare a tickf function using CK_DLL_TICKF

//     // example of adding setter method
//     QUERY->add_mfun( QUERY, package_version_setParam, "float", "param" );
//     // example of adding argument to the above method
//     QUERY->add_arg( QUERY, "float", "arg" );

//     // example of adding getter method
//     QUERY->add_mfun( QUERY, package_version_getParam, "float", "param" );

//     // this reserves a variable in the ChucK internal class to store
//     // referene to the c++ class we defined above
//     package_version_data_offset = QUERY->add_mvar( QUERY, "int", "@c_data", false );

//     // ------------------------------------------------------------------------
//     // end the class definition
//     // IMPORTANT: this MUST be called to each class definition!
//     // ------------------------------------------------------------------------
//     QUERY->end_class( QUERY );

//     // wasn't that a breeze?
//     return TRUE;
// }


// // implementation for the default constructor
// CK_DLL_CTOR( package_version_ctor )
// {
//     // get the offset where we'll store our internal c++ class pointer
//     OBJ_MEMBER_INT( SELF, package_version_data_offset ) = 0;

//     // instantiate our internal c++ class representation
//     PackageVersion * c_obj = new PackageVersion( API->vm->srate(VM) );

//     // store the pointer in the ChucK object member
//     OBJ_MEMBER_INT( SELF, package_version_data_offset ) = (t_CKINT)c_obj;
// }


// // implementation for the destructor
// CK_DLL_DTOR( package_version_dtor )
// {
//     // get our c++ class pointer
//     PackageVersion * c_obj = (PackageVersion *)OBJ_MEMBER_INT( SELF, package_version_data_offset );
//     // clean up (this macro tests for NULL, deletes, and zeros out the variable)
//     CK_SAFE_DELETE( c_obj );
//     // set the data field to 0
//     OBJ_MEMBER_INT( SELF, package_version_data_offset ) = 0;
// }


// // implementation for tick function (relevant only for UGens)
// CK_DLL_TICK( package_version_tick )
// {
//     // get our c++ class pointer
//     PackageVersion * c_obj = (PackageVersion *)OBJ_MEMBER_INT(SELF, package_version_data_offset);

//     // invoke our tick function; store in the magical out variable
//     if( c_obj ) *out = c_obj->tick( in );

//     // yes
//     return TRUE;
// }


// // example implementation for setter
// CK_DLL_MFUN( package_version_setParam )
// {
//     // get our c++ class pointer
//     PackageVersion * c_obj = (PackageVersion *)OBJ_MEMBER_INT( SELF, package_version_data_offset );

//     // get next argument
//     // NOTE argument type must match what is specified above in CK_DLL_QUERY
//     // NOTE this advances the ARGS pointer, so save in variable for re-use
//     t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );

//     // call setParam() and set the return value
//     RETURN->v_float = c_obj->setParam( arg1 );
// }


// // example implementation for getter
// CK_DLL_MFUN(package_version_getParam)
// {
//     // get our c++ class pointer
//     PackageVersion * c_obj = (PackageVersion *)OBJ_MEMBER_INT( SELF, package_version_data_offset );

//     // call getParam() and set the return value
//     RETURN->v_float = c_obj->getParam();
// }
